\documentclass[uplatex,dvipdfmx]{jsarticle}

\usepackage[uplatex,deluxe]{otf} % UTF
\usepackage[noalphabet]{pxchfon} % must be after otf package
\usepackage{stix2} %欧文＆数式フォント
\usepackage[fleqn,tbtags]{mathtools} % 数式関連 (w/ amsmath)
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{hira-stix} % ヒラギノフォント＆STIX2 フォント代替定義（Warning回避）
\usepackage{titlesec} % セクションのフォント変更用
\usepackage{listings} 
\usepackage{url}
\lstset{
basicstyle={\ttfamily}, 
identifierstyle={\small}, 
commentstyle={\smallitshape}, 
keywordstyle={\small\bfseries},  
ndkeywordstyle={\small},  
stringstyle={\small\ttfamily},  
frame={tb},  breaklines=true,  
columns=[l]{fullflexible},  
numbers=left,  xrightmargin=0zw,  xleftmargin=3zw,  
numberstyle={\scriptsize},  stepnumber=1, 
numbersep=1zw,  lineskip=-0.5ex
}

\titleformat*{\section}{\rmfamily\mcfamily\Large} % \sectionのフォントを明朝体に設定
\titleformat*{\subsection}{\rmfamily\mcfamily\Large} 
\titleformat*{\subsubsection}{\rmfamily\mcfamily\Large} 

\begin{document}
\begin{titlepage}
\vspace*{2cm}
\centering
\Huge\textsf{アジャイルワーク2 実験計画書}\\[1.5cm]
\Large\textsf{情報工学科 2年}\\
\Large\textsf{24G1122}\\[5pt]
\huge\textsf{細澤 悠真}

\vspace*{1cm}
\Large\sffamily

\vspace*{2cm}
\Large\textsf{\today}
\end{titlepage}
\newpage
\section{実験目的}
%データ圧縮がなぜ必要なのか
本実験では、Aruduinoを用いた、カラーセンサによる色検出システムの精度を向上させることを目的としていた。そこで、センサから取得したRGB値を整形して、ニューラルネットワークに入力して、色検出の精度が向上するように、重みづけとバイアスを調整できるようにした。
そこで、より色検出の精度を向上させるために、ニューラルネットワークの隠れ層を増やすことにした。隠れ層を増やすことで、より複雑なパターンを学習できるようになり、色検出の精度が向上することが期待される。
しかし、隠れ層の増加に伴って、使用するメモリ量が増加するため、Aruduinoの実行メモリを超過してしまうことがわかった。そこで、本実験では、ニューラルネットワークの隠れ層の数を増やしつつ、Aruduinoの実行メモリを超過しないようにするために、データ圧縮方式を適用する必要がある。
\section{実験の理論}
%どのような方式を適用するのかを調査・選択し記載
%確定できない場合は、複数の方式を比較検討して記載
\subsection{プルーニングと圧縮} %プルーニング…0に近似する
L1正規化の際に、0に近い閾値を設定し、出力された重みが閾値以下の場合は0に置き換える.この操作をプルーニングと呼ぶ。
そして、スパース行列を用いて、非ゼロの要素のみを保持することによって、メモリの使用量を削減する。非ゼロ要素は、元々の行列のインデックスと値をペアで保存する形式（COO形式）と行のポインタと列のインデックスと値のペアで保存する形式(CSR形式)によって、影響を与える値を保持し、圧縮する。これは0以外の要素が減少するほど有効である。

%現在の重みとバイアスはfloat型（32bit）で保存されている。
%これを16bit固定小数点に量子化することで、メモリ使用量を50%削減することができる。
%また、8bit量子化を行うことで、メモリの使用量を75%削減することができる。    
\section{実験方法}
%プログラムの実装、性能確認方法
%複数の方式を試す場合、方式の選択基準
%閾値に関しては近い実験を参考にして選定、またはメモリ削減量の目標から逆算して、閾値を決定する。
\subsection{実験手順}
1. 隠れ層の数を40層から60層の範囲で任意の値を指定し、メモリ最適化を適用する前のニューラルネットワークモデルを構築して、その学習モデルを用いて、色検出を行う。\par
2. プルーニングと圧縮を適用するための閾値を設定する。閾値は、近い実験を参考にして選定するか、メモリ削減量の目標から逆算して決定する。\par
3. 隠れ層の数を40層から60層の範囲で指定し、プルーニングと圧縮を適用したニューラルネットワークモデルを構築して、その学習モデルを用いて、色検出を行う。\par
4. 各実験ごとに、色検出の精度、Aruduino実行メモリ使用量を計測し、プルーニングと圧縮を適用した場合と適用していない場合で、色検出の精度とメモリ使用量の差を比較する。\par
\subsection{プログラムの実装}
\subsubsection{L1正規化による学習}
既存の $train-L1-normalization.ipynb$ を使い、モデルを float型で学習する。L1正則化（重みの絶対値の和にペナルティ）により、多くの重みが小さくなり、プルーニングが効きやすくする。
出力は$model-parameters.h$に出力する。
\subsubsection{プルーニング}
任意の閾値を設定して、その値以下の重みを 0 にすることで、元の重みとバイアス行列をスパース化する。
閾値の設定方法は、絶対値ベースを基準として、重みの絶対値の分布を調査して、特定の小さな値($10^{-2}$)を閾値とする。最終的には「メモリ削減量」と「精度低下」をトレードオフして決める。
出力は$W-pruned.npy、b-pruned.npy$といったNumpy独自のフォーマットのバイナリファイルで保存する。これによって、データ型や形状をそのまま保持することができる。
\subsubsection{COO形式への変換}
プルーニング後の重み行列とバイアス行列をCOO形式に変換する。PythonのSciPyライブラリとPytorchライブラリを使用して、Numpy配列からCOO形式に変換する。具体的には、SciPyの`scipy.sparse.coo-matrix`クラスを使用する。また,
COO形式のデータには、行インデックス、列インデックス、値の3つの配列があり、値の配列のみをfloat32を維持して、行インデックスと列インデックスをuint8に変換することで、さらにメモリ使用量を削減する。
図\ref{fig:coo}にCOO形式の例を示す。
\begin{figure}[h]
    \centering
    \includegraphics[width=0.95\textwidth]{Pruning+COO.pdf}
    \caption{COO形式の変換手順}
    \label{fig:coo}
\end{figure}
\subsubsection{CSR形式への変換}
プルーニング後の重み行列とバイアス行列をCSR形式に変換する。PythonのSciPyライブラリとPytorchライブラリを使用して、Numpy配列からCSR形式に変換する。具体的には、SciPyの`scipy.sparse.csr-matrix`クラスを使用する。また、
CSR形式のデータには、行ポインタ、列インデックス、値の3つの配列があり、値の配列のみをfloat32を維持して、行ポインタと列インデックスをuint8に変換することで、さらにメモリ使用量を削減する。
図\ref{fig:csr}にCSR形式の例を示す。
\begin{figure}[h]
    \centering
    \includegraphics[width=0.95\textwidth]{Pruning+CSR.pdf}
    \caption{CSR形式の変換手順}
    \label{fig:csr}
\end{figure}
\newpage
\subsubsection{ヘッダファイルに自動変換}
Pythonスクリプトで、すべてのレイヤの CSR配列とスケール、行サイズなどをCスタイルで出力します。PROGMEM を使って フラッシュメモリに配置することで、RAM（実行メモリ）の使用量を削減する。
\subsection{性能確認方法}
%精度、メモリ使用量、処理速度など
\subsubsection{精度の性能確認}
隠れ層の数を40層から60層の範囲で指定し、プルーニングと圧縮を適用した場合と適用していない場合で、色検出の精度を比較する。精度は、PPM形式の正解画像と検出結果画像のMSE（平均二乗誤差）によって評価する。
判断基準は、元画像と学習後の検出画像のMSEを比較して、学習後の検出画像のMSEの方がより小さい値になっていれば、精度が向上したと判断する。
異なる二つの画像間のMSEは以下の手順で計算する。\\
画像間のMSEは各画素のRGB成分の差分を二乗して、その平均を取ることで求められる。
\begin{enumerate}
    \item まず、各画素 $(x, y)$ に対して、基準画像および比較画像のRGB値をそれぞれ取得する。
    \begin{align}
        R_{xy}^{(\mathrm{ref})},\; G_{xy}^{(\mathrm{ref})},\; B_{xy}^{(\mathrm{ref})} &: \text{基準画像のRGB成分} \\
        R_{xy}^{(\mathrm{test})},\; G_{xy}^{(\mathrm{test})},\; B_{xy}^{(\mathrm{test})} &: \text{比較画像のRGB成分}
    \end{align}

    \item 各画素ごとに、RGBの差分を計算する。
    \begin{align}
        \Delta R_{xy} &= R_{xy}^{(\mathrm{ref})} - R_{xy}^{(\mathrm{test})} \\
        \Delta G_{xy} &= G_{xy}^{(\mathrm{ref})} - G_{xy}^{(\mathrm{test})} \\
        \Delta B_{xy} &= B_{xy}^{(\mathrm{ref})} - B_{xy}^{(\mathrm{test})}
    \end{align}

    \item 次に、各画素におけるRGB誤差の二乗平均を求める。
    \begin{align}
        E_{xy} = \frac{(\Delta R_{xy})^2 + (\Delta G_{xy})^2 + (\Delta B_{xy})^2}{3}
    \end{align}

    ここで、$E_{xy}$ は画素 $(x, y)$ におけるRGBの平均二乗誤差である。

    \item 最後に、全画素に対して $E_{xy}$ を平均し、画像全体のMSEとする。
    \begin{align}
        \mathrm{MSE} 
        &= \frac{1}{W \times H} 
        \sum_{x=0}^{W-1} \sum_{y=0}^{H-1} E_{xy} \\
        &= \frac{1}{W \times H} 
        \sum_{x=0}^{W-1} \sum_{y=0}^{H-1}
        \frac{(R_{xy}^{(\mathrm{ref})} - R_{xy}^{(\mathrm{test})})^2 + (G_{xy}^{(\mathrm{ref})} - G_{xy}^{(\mathrm{test})})^2 + (B_{xy}^{(\mathrm{ref})} - B_{xy}^{(\mathrm{test})})^2}{3}
    \end{align}

    ここで，
    \begin{itemize}
        \item $W$：画像の幅（ピクセル数）
        \item $H$：画像の高さ（ピクセル数）
    \end{itemize}

\end{enumerate}
\subsubsection{メモリ使用量の性能確認}
各実験ごとに、Aruduino実行メモリ使用量を計測し、プルーニングと圧縮を適用した場合と適用していない場合で、メモリ使用量の差を比較する。測定方法は、Arduino IDEの「環境設定」で「コンパイル」の出力を詳細表示に設定し、コンパイル後に表示されるメッセージからフラッシュメモリ（プログラムコード）とRAM（変数など）の使用量を読み取ることで行う。
元々のメモリ使用量では、隠れ層の数が60までしか対応できなかったので、プルーニングと圧縮を適用した結果、隠れ層の数を60層以上に増やしても、Aruduinoの実行メモリを超過しないことを確認できたら、メモリ使用量の削減に成功したと判断する。
メモリ削減率は以下の式で計算する。\\
\[
\text{メモリ削減率} = \frac{\text{元のメモリ使用量} - \text{最適化後のメモリ使用量}}{\text{元のメモリ使用量}} \times 100\%
\]
\end{document}

% 